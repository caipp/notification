#新手也能看懂的监控报警系统架构设计
http://developer.51cto.com/art/201805/573511.htm

企业级的监控数据，通常包括如下三类：
网络数据，包括骨干交换机，核心交换机等硬件设备。
服务器数据，包括服务器的 CPU、内存、硬盘的各项使用数据。
应用数据。



应用数据是这三者中最难的，但也是最重要的。
应用数据是和业务逻辑紧密相关的数据，业务逻辑变了，应用数据的收集也会变化。 
在应用数据这一块，有一个开源项目叫 Statsd，它催生了“应用数据收集标准” <github-statsd 应用数据收集标准>。


#1.存储数据
监控报警的数据，全部都是围绕“监控指标的值随时间变化的趋势”这一目标而设计的。每一项监控指标数据序列都是天然的按“时间排序”的，这是其特点。
业界管存储这种数据结构的工具叫“时间序列数据库”。这是一种专有数据库，并非像 RDBMS（关系型数据库）是一种通用的 SQL-LIKE 的数据库。
市面上有很多很多的基于时间序列的数据库，不论其底层的数据结构实现是什么样子，时间序列存储的本质数据结构永远都是：
Map< METRIC_KEY , sortedMap<timestamp, METRIC_VALUE >>

一定要选择高可用 HA（High Available）的数据存储解决方案。


不同的底层实现都是在上面这个数据结构的一些点上有不同的扩展，比如：
s1.在 METRIC_KEY 的分片逻辑，实现上不同：选取的分片是一致性哈希，还是求余哈希。
s2.SortedMap 的实现不同，本质上是一个按 Timestamp 排序的序列。
s3.读写的偏好略有不同。


那么根据业务场景，又有了其他几个选型点：
1.Metrics 是否会无限增加？
2.Metrics 保留的时间跨度有多长？
3.上层的业务报警，有多重要？(HA & 高可用性)



#2.报警规则

报警规则模块，首先，是天然个性的。为什么呢？按什么规则报警，显然是和每个公司的具体业务绑定的。
而规则是基于对历史数据的分析、度量。

##报警规则有哪些通用的技术点：
1.High-Available 的规则周期检查

企业级的应用，最强调的就是高可用 HA，必须避免单点故障 SPOF。“报警规则模块”发生问题了，仍然会导致“监控报警”系统失效。
一般来说，报警规则都是周期性触发的。因此需要有一个“类Cron Job”的调度器。
这类调度系统的 HA 设计可以参考“Azkaban” 和 “Quartz”：
Azkaban：https://azkaban.github.io/
Quartz：http://www.quartz-scheduler.org/
调度系统的 HA 设计主要分为“规则数据库的高可用”和“调度 Sever 的高可用”两方面：
数据库高可用通过 Master-Slave 的主从实现。
调度 Server 的高可用，如果有状态，则使用 zk／etcd 来做高可用；如果无状态，那就启动多个调度服务器好了。根据调度规则，制定一定的分片策略，不算困难。

2.报警规则定义
两种“报警规则”的定义实现方式：
基于“规则表达式的”。
基于直接“脚本&编程”的。

基于规则表达式的：在熟悉了表达式语言后，比较容易编写，但灵活性差。在实现复杂的报警规则时比较难，一般适用于简单的报警规则。

基于“脚本／编程”的，这种类型的规则定义，提供了无限的灵活性。因为“可编程”，就等于可以“do everything”。
报警规则“脚本”定义的例子： 收集两个数据源的数据，根据自定义规则，判断指标是否异常，如果有异常，先进行“重启”行为，缓解线上压力，再发出报警给相关工程师，追查真正原因。
这种稍微复杂的报警规则，用编程脚本的方式实现起来毫无压力，而如果要用基于规则语言的报警，则比较困难，甚至是不可能实现的。

#3.报警行为

不外乎就是在报警规则触发后，通过电话、微信、短信、邮件等媒介找到正确的负责人

检测 Hadoop Namenode 健康的报警每 5 分钟一次，是否每一次检测失败了都要报警？会不会有误报？
第一次异常报警后，工程师已经在排查问题了，这时连续的第二次、第三次检测异常，是否需要连续的打电话去打扰工程师？ 那么，连续几次抑制报警呢？





#Prometheus报警AlertManager实战
https://blog.qikqiak.com/post/alertmanager-of-prometheus-in-practice/










